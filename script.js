// Question 1(a)
function countMembershipLevels(members){
    array[
    {
        name: 'sonia',
        membershiplevel: "gold"
    }
    = {
        name: 'michu',
        membershiplevel: "silver"
    }
    = {
        name: 'mimi',
        membershiplevel: "gold"
    }
    = {
        name: 'eunice',
        membershiplevel: "platinum"
    }
    = {
        name: 'sonia',
        membershiplevel: "gold" 
    }
    ]
    return (`${name}: ${count(membershiplevel)}`)
    
}

// ************************************************************************************************

// Question 1(b)
function getGoldMembers(members){
    if(array.filter('gold')){
        return member
    }else{
        return "No gold members found"
    }
}
// **************************************************************************************************
// Question 1(c)
// array.filter(getGoldMembers)
// function getGoldMembers(members){
//     if ()
// }

// Question 1(d)
array.map((generateWelcomeMessages))
function  generateWelcomeMessages(members){
return `"Welcome, ${name}! You are a ${memvershiplevel} member."`
  };
// Question 1(e)
// Map is often  preferred over traditional loops for transforming data in arrays, as an array method used in 
// changing or transorming array elements in new ways in easy and quick way with the performance of bring new 
// array elements at the same time while passing through each element, this helps a reader of the codes to not
// be confused or mistaken by the array given

// QUESTION 2************************************************************************************************
// (A)
// function sumDigits(n){
//  return split().foreach()
// }
let results = split(sumDigits)
function sumDigits(n){
fore = foreach(a, b, c)
return a + b + c;
}

// (B)

function power(base, exponent){
    return base **exponent
}
console.log(power(2,3))
// (C)

function reverseWords(sentence){
   return reverse(a, b)
} 
console.log(reverseWords('WE BT'))
// (D)
//Recursion is less efficient than iteration when it comes in calculating many number or infinite numbers that may
// take a much time and strong functionality of the computer as iteration easily loops the numbers making the programmer
// not to take time looping
// EXAMPLE: Calcuting the multiplication of infinite numbers

// (E)

// (F)
function reversed(string){
    return split().reverse().join()
}

// QUESTION 3 Banking Transaction System **********************************
array[
    {
        transactionId: '',
        accountHolder: '',
        amount: function amounts(nbr, dep, wd){
            return 
        }
       
    }
]
// A
// function calculateBalance(transactions, accountHolder){
//     return reduce(a,b)
// }
// array.reduce(calculateBalance)
function calculateBalance(transactions, accountHolder){
    return transactions + accountHolder
}
// B
let result = array.filter(largeTransactions)
function largeTransactions(transactions, minAmount){
return filter(transaction > minAmount)
}
console.log(result)

// C
function sortTransactions(transactions){
}
let finalresult = sort(sortTransactions)
function sortTransactions(transactions){
    return a - b;
}

// D

function generateTransactionHistory(transactions, accountHolder){
    if(transactions > 1){
        console.log(`${accountHolder} deposits ${transactions}`)
    }
    else{
        console.log(`${accountHolder} withdrew ${transactions}`)
    }
}
// ADDITIONAL CHANGES

// E*******


// QUESTION 4
// A
function countProjectVotes(votes){
    const votes = [ 
        { student: "Alice", project: "Project A" }, 
        { student: "Bob", project: "Project B" },
        { student: "Charlie", project: "Project A" } 
 ]; 
 let tvotes = reduce(`${project}: ${votes}`)
        return countProjectVotes
}

// B

function findWinningProject(votes){
    return Math.max(votes)
}

// C
function getUniqueProjects(votes){
    return Set(votes)
}

// D
function findWinningProject(votes){
    if(array == null && array == Error){
        console.log("No votes cast") 
    }
    return findWinningProject;
}

// E
// Reduce is more preffered because it checks all the elements with just using one method rather than for loop
// that uses multiple formulas to get to the final result
// Reduce also simplifies the line of codes making the codes appear less than expected rather than loop that gives 
// multiple line of codes.

// F
